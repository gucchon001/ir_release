ir_news_release
├── .gitignore
├── .pytest_cache
│   ├── .gitignore
│   ├── CACHEDIR.TAG
│   ├── README.md
│   └── v
│       └── cache
│           ├── lastfailed
│           ├── nodeids
│           └── stepwise
├── .req_hash
├── README.md
├── config
│   ├── boxwood-dynamo-384411-6dec80faabfc.json
│   ├── prompt_financial_report.json
│   ├── secrets.env
│   └── settings.ini
├── docs
│   ├── .gitkeep
│   ├── detail_spec.txt
│   ├── generate_detailed_spec.txt
│   ├── merge.txt
│   └── requirements_spec.txt
├── requirements.txt
├── run.bat
├── spec_tools_run.bat
├── src
│   ├── __init__.py
│   ├── main.py
│   ├── modules
│   │   ├── __init__.py
│   │   ├── edinet
│   │   │   ├── __init__.py
│   │   │   ├── config.py
│   │   │   └── operations.py
│   │   ├── pdfSummary
│   │   │   ├── __init__.py
│   │   │   ├── extractor.py
│   │   │   ├── pdf_main.py
│   │   │   ├── process_drive_file.py
│   │   │   ├── summarizer.py
│   │   │   └── tokenizer.py
│   │   ├── setup.py
│   │   ├── slack
│   │   │   └── slack_notify.py
│   │   └── spreadsheet_to_edinet.py
│   └── utils
│       ├── __init__.py
│       ├── date_utils.py
│       ├── drive_handler.py
│       ├── environment.py
│       ├── logging_config.py
│       └── spreadsheet.py
└── tests
    ├── README.md
    ├── __init__.py
    ├── test_drive_file.py
    ├── test_log.py
    ├── test_slack_notify.py
    ├── test_slack_notify_with_file.py
    ├── test_slack_notify_with_markdown.py
    ├── test_spreadsheet.py
    └── test_template.py

# Merged Python Files


================================================================================
File: src\__init__.py
================================================================================

 


================================================================================
File: src\main.py
================================================================================

#main.py
from typing import Callable, Optional, Any
from datetime import datetime, timedelta

from modules.edinet.operations import EDINETOperations
from modules.edinet.config import EDINETConfig
from modules.spreadsheet_to_edinet import process_spreadsheet_data
from utils.spreadsheet import SpreadsheetService
from utils.environment import EnvironmentUtils as env
from utils.date_utils import parse_date_string
from utils.logging_config import get_logger

# 名前付きロガーを取得
logger = get_logger(__name__)

def initialize_debug_tools() -> None:
    """
    デバッグツールを初期化
    """
    try:
        use_icecream = env.get_config_value(env.get_environment(), "USE_ICECREAM", default=False)
        # ロガー初期化時にIceCreamの設定を反映
        get_logger(__name__, use_icecream=use_icecream)
    except Exception as e:
        logger.error(f"Failed to initialize debug tools: {e}")
        raise

def run_process(process_func: Callable, config: Optional[Any] = None) -> None:
    """汎用プロセス実行関数"""
    try:
        logger.info(f"Starting process: {process_func.__name__}")
        process_func(config)
        logger.info(f"Process {process_func.__name__} completed successfully.")
    except Exception as e:
        logger.error(f"Error in {process_func.__name__}: {e}", exc_info=True)
        raise RuntimeError(f"Process {process_func.__name__} failed.") from e

def edinet_process(config: EDINETConfig) -> None:
    """
    EDINET API を使用して指定された期間内のドキュメントを取得
    """
    edinet = EDINETOperations(
        base_url=config.base_url,
        api_key=config.api_key,
        parent_folder_id=config.parent_folder_id,
        service_account_file=config.service_account_file,
    )

    start_date_str = env.get_config_value("DATE_RANGE", "start_date")
    end_date_str = env.get_config_value("DATE_RANGE", "end_date")

    if not start_date_str or not end_date_str:
        raise ValueError("DATE_RANGE section or required keys are missing in the settings.ini file.")

    # 動的な日付解析
    start_date = parse_date_string(start_date_str)
    end_date = parse_date_string(end_date_str)
    
    logger.debug(f"Fetching documents from {start_date} to {end_date}")

    spreadsheet_service = SpreadsheetService()
    spreadsheet_id = spreadsheet_service.get_spreadsheet_id("SPREADSHEET", "ss_id_list")
    list_data = spreadsheet_service.get_sheet_data(spreadsheet_id, "list")

    if not list_data or len(list_data) < 2:
        logger.error("Spreadsheet data is empty or invalid format.")
        raise ValueError("Spreadsheet data is empty or invalid format.")

    headers = list_data[0]
    data_rows = list_data[1:]
    edinet_code_index = headers.index("EDINET_code")
    edinet_codes_from_sheet = [row[edinet_code_index] for row in data_rows]

    logger.info(f"Edinet codes retrieved from spreadsheet.")

    documents = edinet.get_documents_for_date_range(
        start_date=start_date,
        end_date=end_date,
        edinet_codes_from_sheet=edinet_codes_from_sheet
    )

    logger.info(f"Total documents retrieved: {len(documents)}")
    for document in documents:
        logger.debug(f"Retrieved Document - ID: {document.get('docID')}, Description: {document.get('docDescription')}")

def main() -> None:
    """メイン処理"""
    try:
        # 環境変数のロード
        env.load_env()

        # 設定ファイルの取得
        config_path = env.get_config_file()
        logger.info(f"Config file located at: {config_path}")

        # EDINETの設定を初期化
        edinet_config = EDINETConfig()
        edinet_config.config_path = config_path

        logger.info(f"Current environment: {env.get_environment()}")

        # デバッグツールの初期化
        initialize_debug_tools()

        # 各プロセスの実行
        run_process(edinet_process, edinet_config)
        run_process(process_spreadsheet_data, edinet_config)

    except Exception as e:
        logger.error(f"Fatal error in main execution: {e}", exc_info=True)

if __name__ == "__main__":
    main()


================================================================================
File: src\modules\__init__.py
================================================================================

# src/modules/__init__.py
from . import pdfSummary
from . import edinet

================================================================================
File: src\modules\edinet\__init__.py
================================================================================

 


================================================================================
File: src\modules\edinet\config.py
================================================================================

#config.py
from pathlib import Path
from typing import Optional
from utils.environment import EnvironmentUtils as env
from utils.logging_config import get_logger

# 名前付きロガーを取得
logger = get_logger(__name__)

class EDINETConfig:
    REQUIRED_KEYS = ['base_url', 'api_key', 'parent_folder_id']

    def __init__(self, environment: Optional[str] = None):
        """
        EDINETConfigの初期化

        Args:
            environment (Optional[str]): 環境名（デフォルトは現在の環境を自動取得）
        """
        self.environment = environment or env.get_environment()
        self.settings = {}

        logger.info(f"Initializing EDINETConfig for environment: {self.environment}")

        # .envファイルをロード
        self._load_env()

        # 設定の読み込みと検証
        self._load_settings()
        self._validate_settings()

    def _load_env(self):
        """
        環境変数をロードする
        """
        try:
            env.load_env()
            logger.info("Environment variables loaded successfully.")
        except FileNotFoundError as e:
            logger.error(f"Environment file not found: {e}")
            raise

    def _load_settings(self):
        """
        EnvironmentUtilsを利用して設定を読み込む
        """
        try:
            # 環境変数または設定ファイルから設定をロード
            self.settings['api_key'] = env.get_env_var("EDINET_API_KEY", default=env.get_config_value("EDINET", "api_key"))
            if not self.settings['api_key']:
                logger.warning("API key is missing. Please set 'EDINET_API_KEY' or define it in settings.ini.")

            self.settings['base_url'] = env.get_config_value('EDINET', 'base_url', default="https://disclosure.edinet-fsa.go.jp/api/v1")
            self.settings['parent_folder_id'] = env.get_config_value('DRIVE', 'parent_folder_id', default="")

            # サービスアカウントファイルをsecrets.envまたは設定ファイルから取得
            service_account_file = env.get_env_var("SERVICE_ACCOUNT_FILE", default=env.get_config_value("GOOGLE", "service_account_file"))
            if not service_account_file:
                raise ValueError("Service account file is missing. Please set 'SERVICE_ACCOUNT_FILE' in secrets.env or settings.ini.")

            self.settings['service_account_file'] = self._resolve_path(service_account_file)
            self.settings['download_dir'] = env.get_config_value('EDINET', 'download_dir', default="data/edinet")

            logger.info("Configuration settings loaded successfully.")
        except Exception as e:
            logger.error(f"Failed to load settings: {e}")
            raise

    def _validate_settings(self):
        """
        設定値の検証

        Raises:
            ValueError: 必須キーが欠落している場合
        """
        logger.info("Validating configuration settings...")
        missing_keys = [key for key in self.REQUIRED_KEYS if not self.settings.get(key)]
        if not self.settings.get('service_account_file'):
            missing_keys.append('service_account_file')

        if missing_keys:
            logger.error(f"Missing required configuration keys: {', '.join(missing_keys)}")
            raise ValueError(f"Missing required configuration keys: {', '.join(missing_keys)}")
        logger.info("All required settings are valid.")

    def _resolve_path(self, path: str) -> Path:
        """
        指定されたパスをプロジェクトルートに基づいて解決します。

        Args:
            path (str): 相対パスまたは絶対パス

        Returns:
            Path: 解決された絶対パス
        """
        resolved_path = Path(path)
        if not resolved_path.is_absolute():
            resolved_path = env.get_project_root() / resolved_path

        if not resolved_path.exists():
            logger.error(f"Resolved path does not exist: {resolved_path}")
            raise FileNotFoundError(f"Resolved path does not exist: {resolved_path}")

        return resolved_path

    @property
    def base_url(self) -> str:
        """
        EDINET APIのベースURLを取得
        """
        return self.settings.get('base_url')

    @property
    def api_key(self) -> str:
        """
        EDINET APIキーを取得
        """
        return self.settings.get('api_key')

    @property
    def parent_folder_id(self) -> str:
        """
        Google Driveの親フォルダIDを取得
        """
        return self.settings.get('parent_folder_id')

    @property
    def service_account_file(self) -> Path:
        """
        サービスアカウントファイルのパスを取得
        """
        return self.settings.get('service_account_file')

    def get_download_dir(self) -> Path:
        """
        ダウンロードディレクトリのパスを取得

        Returns:
            Path: ダウンロードディレクトリのパス
        """
        download_dir = Path(self.settings.get('download_dir'))
        if not download_dir.is_absolute():
            download_dir = env.get_project_root() / download_dir
        download_dir.mkdir(parents=True, exist_ok=True)
        return download_dir


================================================================================
File: src\modules\edinet\operations.py
================================================================================

#operations.py
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import requests
from google.oauth2 import service_account
from googleapiclient.discovery import build
from utils.environment import EnvironmentUtils as env
from utils.logging_config import get_logger
import os
from concurrent.futures import ThreadPoolExecutor, as_completed

# 名前付きロガーを取得
logger = get_logger(__name__)

class EDINETOperations:
    """EDINET API操作クラス"""

    TARGET_DOC_TYPES: Dict[str, str] = {
        '120': '有価証券報告書',
        '140': '四半期報告書',
        '160': '半期報告書'
    }

    def __init__(self, base_url: Optional[str] = None, api_key: Optional[str] = None, 
                 parent_folder_id: Optional[str] = None, service_account_file: Optional[str] = None, 
                 max_workers: int = 10):
        """
        EDINETOperations クラスの初期化
        """
        logger.info("EDINET Operations を初期化中...")

        # 環境変数をロード
        env.load_env()

        # 必要な設定をEnvironmentUtilsから取得
        try:
            self.base_url = base_url or env.get_config_value("EDINET", "base_url")
            self.api_key = api_key or os.getenv("EDINET_API_KEY")  # 環境変数から取得
            self.parent_folder_id = parent_folder_id or env.get_config_value("DRIVE", "parent_folder_id")
            self.service_account_file = service_account_file or env.get_service_account_file()

            # 設定値が不足している場合にエラーをスロー
            missing_config = []
            if not self.base_url:
                missing_config.append("base_url")
            if not self.api_key:
                missing_config.append("api_key")
            if not self.service_account_file:
                missing_config.append("service_account_file")

            if missing_config:
                raise ValueError(f"必要な設定値が不足しています: {', '.join(missing_config)}")
            
            logger.debug("設定値を正常にロードしました。")

        except Exception as e:
            logger.error(f"EDINETOperations の初期化に失敗しました: {e}")
            raise

        # Google Drive APIを初期化
        self.drive_service = None
        self.initialize_drive_service()

        # ThreadPoolExecutorの最大スレッド数
        self.max_workers = max_workers

    def initialize_drive_service(self):
        """Google Drive APIサービスの初期化"""
        try:
            credentials = service_account.Credentials.from_service_account_file(
                str(self.service_account_file),
                scopes=['https://www.googleapis.com/auth/drive.file']
            )
            self.drive_service = build('drive', 'v3', credentials=credentials)
            logger.info("Google Drive サービスを正常に初期化しました。")
        except Exception as e:
            logger.error(f"Drive サービスの初期化に失敗しました: {e}")
            self.drive_service = None

    def get_documents_for_date_range(self, start_date: datetime, end_date: datetime, edinet_codes_from_sheet: List[str]) -> List[Dict]:
        """
        指定期間のEDINET文書を取得

        Args:
            start_date (datetime): 開始日
            end_date (datetime): 終了日
            edinet_codes_from_sheet (List[str]): スプレッドシートから取得したEDINETコードリスト

        Returns:
            List[Dict]: 文書情報のリスト
        """
        documents = []
        total_days = (end_date - start_date).days + 1
        dates = [(start_date + timedelta(days=day_offset)).strftime('%Y-%m-%d') for day_offset in range(total_days)]

        logger.info(f"{total_days} 日分のドキュメントを並列で取得開始します。")

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_date = {executor.submit(self.fetch_documents_for_date, date, edinet_codes_from_sheet): date for date in dates}
            for future in as_completed(future_to_date):
                date = future_to_date[future]
                try:
                    daily_documents = future.result()
                    documents.extend(daily_documents)
                    logger.debug(f"{date} のドキュメントを {len(daily_documents)} 件取得しました。")
                except Exception as e:
                    logger.error(f"{date} のドキュメント取得中に例外が発生しました: {e}")

        logger.info(f"指定期間内に取得した総ドキュメント数: {len(documents)}")
        return documents

    def fetch_documents_for_date(self, target_date: str, edinet_codes_from_sheet: List[str]) -> List[Dict]:
        """
        指定日のEDINET文書を取得

        Args:
            target_date (str): 対象日 (YYYY-MM-DD)
            edinet_codes_from_sheet (List[str]): スプレッドシートから取得したEDINETコードリスト

        Returns:
            List[Dict]: フィルタリングされた文書情報のリスト
        """
        filtered_results = []
        logger.debug(f"{target_date} のドキュメントを取得中...")

        try:
            url = f"{self.base_url}/documents.json"
            params = {
                "date": target_date,
                "type": "2",
                "Subscription-Key": self.api_key
            }
            response = requests.get(url, params=params, timeout=10)

            if response.status_code != 200:
                logger.warning(f"{target_date} のレスポンスが成功ではありませんでした: {response.text}")
                return []

            data = response.json()
            results = data.get('results', [])

            # フィルタリング対象のEDINETコードのみ取得
            filtered_results = [
                doc for doc in results
                if (doc.get('edinetCode') in edinet_codes_from_sheet and
                    doc.get('docTypeCode') in self.TARGET_DOC_TYPES and
                    doc.get('pdfFlag') == '1')
            ]

            logger.info(f"{target_date} のフィルタリング結果数: {len(filtered_results)}")
            return filtered_results

        except requests.exceptions.RequestException as e:
            logger.error(f"{target_date} のドキュメント取得に失敗しました: {e}")
            return []
        except Exception as e:
            logger.error(f"{target_date} の処理中に予期しないエラーが発生しました: {e}")
            return []

    def fetch_document_data(self, doc_id: str, doc_type_code: str) -> Optional[bytes]:
        """
        EDINET APIからPDFデータを取得

        Args:
            doc_id (str): ドキュメントID
            doc_type_code (str): ドキュメントタイプコード

        Returns:
            Optional[bytes]: PDFデータ、またはNone
        """
        url = f"{self.base_url}/documents/{doc_id}"
        params = {
            "type": "2",  # PDFデータ形式を指定
            "Subscription-Key": self.api_key,
        }

        logger.debug(f"doc_id {doc_id} のPDFドキュメントをリクエスト中...")

        try:
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()

            # PDFフォーマットチェック
            if not response.content.startswith(b'%PDF-'):
                logger.error(f"doc_id {doc_id} のPDFフォーマットが無効です。")
                return None

            logger.debug(f"doc_id {doc_id} のPDFドキュメントを正常に取得しました。サイズ: {len(response.content)} バイト")
            return response.content
        except requests.exceptions.RequestException as e:
            logger.error(f"doc_id {doc_id} のドキュメント取得に失敗しました: {e}")
            return None


================================================================================
File: src\modules\pdfSummary\__init__.py
================================================================================

 
# src/modules/pdfSummary/__init__.py
from . import pdf_main
from . import extractor
from . import tokenizer
from . import summarizer

================================================================================
File: src\modules\pdfSummary\extractor.py
================================================================================

import pymupdf
from utils.logging_config import get_logger  # 修正: 絶対パスを使用

logger = get_logger(__name__)

def extract_text_from_pdf(pdf_path):
    """
    PyMuPDF を使用してPDFからテキストを抽出します。

    Args:
        pdf_path (str): PDFファイルのパス。

    Returns:
        str: 抽出されたテキスト。
    """
    logger.info(f"PDF ファイルからテキストを抽出: {pdf_path}")
    text = ""
    try:
        doc = pymupdf.open(pdf_path)
        for page_num, page in enumerate(doc, start=1):
            page_text = page.get_text()
            if page_text:
                text += page_text + "\n\n"
            logger.debug(f"ページ {page_num}: テキスト抽出完了")
    except Exception as e:
        logger.error(f"PyMuPDF によるテキスト抽出に失敗しました: {e}")
        raise
    logger.info(f"抽出されたテキストの合計文字数: {len(text)}")
    return text


================================================================================
File: src\modules\pdfSummary\pdf_main.py
================================================================================

# src/modules/pdfSummary/pdf_main.py

import openai  # OpenAI SDK の正しいインポート方法
from pathlib import Path
import json

from utils.environment import EnvironmentUtils as env
from utils.drive_handler import DriveHandler
from .extractor import extract_text_from_pdf
from .tokenizer import Tokenizer
from .summarizer import Summarizer

from utils.logging_config import get_logger

logger = get_logger(__name__)

def load_prompt(file_path: str) -> list:
    """
    プロンプトファイルをロードする

    Args:
        file_path (str): プロンプトファイルのパス

    Returns:
        list: プロンプトメッセージのリスト
    """
    try:
        with open(file_path, "r", encoding="utf-8") as file:
            prompt_data = json.load(file)
            return prompt_data["messages"]
    except Exception as e:
        logger.error(f"プロンプトのロード中にエラーが発生しました: {e}")
        raise

def process_pdf(pdf_path: str, folder_id: str, drive_handler: DriveHandler = None) -> list:
    """
    PDF を処理して要約を作成し、Google Drive に保存します。

    Args:
        pdf_path (str): PDF ファイルのパス。
        folder_id (str): 要約を保存する Google Drive フォルダの ID。
        drive_handler (DriveHandler, optional): 既存のDriveHandlerインスタンス。

    Returns:
        list: Google Drive に保存された要約ファイルの ID のリスト。
    """
    logger.info(f"PDF 処理を開始: {pdf_path}")

    # 環境変数をロード
    try:
        env.load_env()
        logger.info("環境変数を正常にロードしました。")
    except Exception as e:
        logger.error(f"環境変数のロード中にエラーが発生しました: {e}")
        raise

    # 必要な情報をロード
    api_key = env.get_openai_api_key()
    model = env.get_openai_model()
    max_chunk_tokens = 2000  # 分割サイズ
    max_summary_tokens = 2000  # 要約トークン制限

    # プロンプトをロード
    prompt_path = env.get_config_value("OPENAI", "prompt_financial_report", default="config/prompt_financial_report.json")
    prompt_file_path = env.resolve_path(prompt_path)
    try:
        prompt_messages = load_prompt(prompt_file_path)
        logger.info("プロンプトを正常にロードしました。")
    except Exception as e:
        logger.error(f"プロンプトのロードに失敗しました: {e}")
        raise

    # 必要なインスタンスを生成
    openai.api_key = api_key  # OpenAI API キーを設定
    tokenizer = Tokenizer(model, max_chunk_tokens)
    summarizer = Summarizer(openai, model, max_summary_tokens, prompt_messages)

    # DriveHandlerのインスタンス生成（既存のDriveHandlerがあれば使用）
    if drive_handler is None:
        service_account_file = env.get_service_account_file()
        drive_handler = DriveHandler(str(service_account_file))

    # PDFからテキストを抽出
    try:
        text = extract_text_from_pdf(pdf_path)
    except Exception as e:
        logger.error(f"PDF テキスト抽出中にエラーが発生しました: {e}")
        raise

    # テキストを分割し要約
    try:
        chunks = tokenizer.split_text_into_chunks(text)
        summary = summarizer.summarize_text(chunks)
    except Exception as e:
        logger.error(f"要約処理中にエラーが発生しました: {e}")
        raise

    # 要約をGoogle Driveに保存
    try:
        file_ids = []
        if len(summary) > 10000:
            # 要約が長すぎる場合に分割保存
            parts = [summary[i:i+10000] for i in range(0, len(summary), 10000)]
            for idx, part in enumerate(parts):
                part_file_name = f"{Path(pdf_path).stem}_summary_part_{idx+1}.md"
                file_id = drive_handler.save_summary_to_drive(folder_id, part, part_file_name)
                file_ids.append(file_id)
                logger.info(f"分割要約をGoogle Drive に保存しました。ファイル ID: {file_id}")
        else:
            # 通常保存
            file_name = Path(pdf_path).stem + "_summary.md"
            file_id = drive_handler.save_summary_to_drive(folder_id, summary, file_name)
            file_ids.append(file_id)
            logger.info(f"要約をGoogle Drive に保存しました。ファイル ID: {file_id}")
        return file_ids  # 要約ファイルのIDリストを返す
    except Exception as e:
        logger.error(f"Google Drive に保存中にエラーが発生しました: {e}")
        raise

def test_process_drive_file(file_id: str, drive_folder_id: str):
    """
    Google DriveのPDFファイルを処理するテスト関数
    
    Args:
        file_id (str): 処理対象のPDFファイルのGoogle Drive ID
        drive_folder_id (str): 保存先フォルダのGoogle Drive ID
    """
    try:
        # DriveHandlerのインスタンス作成
        service_account_file = env.get_service_account_file()
        drive_handler = DriveHandler(str(service_account_file))
        
        # PDFファイルをダウンロードして処理
        local_pdf_path = drive_handler.download_pdf_from_drive(file_id)
        if local_pdf_path:
            # PDFの処理 - DriveHandler を渡す
            result = process_pdf(local_pdf_path, drive_folder_id, drive_handler)
            
            if result:
                print(f"処理が完了しました。結果のファイルID: {result}")
            else:
                print("PDFの処理に失敗しました")
        else:
            print("PDFのダウンロードに失敗しました")
            
    except Exception as e:
        print(f"エラーが発生しました: {e}")
        raise


================================================================================
File: src\modules\pdfSummary\process_drive_file.py
================================================================================

# src/modules/pdfSummary/process_drive_file.py

from .pdf_main import process_pdf
from utils.environment import EnvironmentUtils as env
from utils.drive_handler import DriveHandler
from utils.logging_config import get_logger

logger = get_logger(__name__)

def process_drive_file(file_id: str, drive_folder_id: str) -> list:
    """
    Google DriveのPDFファイルを処理して要約を生成し、ファイルIDのリストを返す

    Args:
        file_id (str): 処理対象のPDFファイルのGoogle Drive ID
        drive_folder_id (str): 保存先フォルダのGoogle Drive ID

    Returns:
        list: 要約ファイルのGoogle DriveファイルIDのリスト
    """
    try:
        # サービスアカウントファイルの取得
        service_account_file = env.get_service_account_file()
        drive_handler = DriveHandler(str(service_account_file))

        # PDFファイルをダウンロードして処理
        local_pdf_path = drive_handler.download_pdf_from_drive(file_id)
        if local_pdf_path:
            # PDFの処理
            result = process_pdf(local_pdf_path, drive_folder_id, drive_handler)
            if result:
                logger.info(f"処理が完了しました。結果のファイルID: {result}")
                return result
            else:
                logger.error("PDFの処理に失敗しました")
                return []
        else:
            logger.error("PDFのダウンロードに失敗しました")
            return []
    except Exception as e:
        logger.error(f"エラーが発生しました: {e}")
        return []


================================================================================
File: src\modules\pdfSummary\summarizer.py
================================================================================

import tiktoken
from concurrent.futures import ThreadPoolExecutor
from utils.logging_config import get_logger

logger = get_logger(__name__)

class Summarizer:
    def __init__(self, client, model, max_summary_tokens, prompt_messages):
        self.client = client
        self.model = model
        self.max_summary_tokens = max_summary_tokens
        self.prompt_messages = prompt_messages
        self.encoding = tiktoken.encoding_for_model(model)  # tiktoken のエンコーディングを取得

    def summarize_chunk(self, chunk):
        """
        単一のチャンクを要約します。
        """
        logger.info("チャンクを要約します。")
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    *self.prompt_messages,  # プロンプトメッセージを適用
                    {"role": "user", "content": chunk}
                ],
                max_tokens=self.max_summary_tokens,
                temperature=0.7
            )
            summary = response.choices[0].message.content.strip()
            logger.debug(f"要約結果: {summary[:100]}...")
            return summary
        except Exception as e:
            logger.error(f"チャンクの要約に失敗しました: {e}")
            raise

    def summarize_text(self, chunks):
        """
        複数のチャンクをまとめて要約。
        """
        logger.info("複数チャンクをまとめて要約します。")
        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    *self.prompt_messages,
                    {"role": "user", "content": "\n\n".join(chunks)}
                ],
                max_tokens=self.max_summary_tokens,
                temperature=0.7
            )
            summary = response.choices[0].message.content.strip()
            logger.info("要約完了。")
            return summary
        except Exception as e:
            logger.error(f"要約全体の処理に失敗しました: {e}")
            raise

    def _summarize_recursive(self, summaries):
        """
        部分要約が長すぎる場合、さらに分割して再要約します。
        """
        combined_summary = " ".join(summaries)
        token_count = len(self.encoding.encode(combined_summary))  # トークン数を計算

        if token_count <= self.max_summary_tokens:
            return self.summarize_chunk(combined_summary)  # トークン数内なら要約

        logger.info("再要約のため、要約をさらに分割します。")
        midpoint = len(summaries) // 2
        left_summary = self._summarize_recursive(summaries[:midpoint])
        right_summary = self._summarize_recursive(summaries[midpoint:])

        return self.summarize_chunk(f"{left_summary} {right_summary}")


================================================================================
File: src\modules\pdfSummary\tokenizer.py
================================================================================

from sentence_transformers import SentenceTransformer, util
import tiktoken
from utils.logging_config import get_logger

logger = get_logger(__name__)

class Tokenizer:
    def __init__(self, model, max_chunk_tokens):
        self.encoding = tiktoken.encoding_for_model(model)
        self.max_chunk_tokens = max_chunk_tokens
        self.sentence_model = SentenceTransformer('all-MiniLM-L6-v2')  # センテンスエンベディングモデル

    def count_tokens(self, text):
        """テキスト内のトークン数をカウントします。"""
        token_count = len(self.encoding.encode(text))
        logger.debug(f"トークン数: {token_count}")
        return token_count

    def split_text_into_chunks(self, text):
        """意味的に近いまとまりでテキストを分割します。"""
        logger.info("テキストを意味的に分割します。")

        # テキストを文単位に分割
        sentences = [sentence.strip() for sentence in text.split(".") if sentence.strip()]
        
        # 各文をエンコードしてセンテンスエンベディングを取得
        embeddings = self.sentence_model.encode(sentences, convert_to_tensor=True)

        # 意味的に近い文をグループ化する
        clusters = []
        current_cluster = []
        current_cluster_length = 0

        for i, sentence in enumerate(sentences):
            sentence_tokens = self.count_tokens(sentence)

            if current_cluster_length + sentence_tokens > self.max_chunk_tokens:
                clusters.append(" ".join(current_cluster))
                current_cluster = []
                current_cluster_length = 0

            current_cluster.append(sentence)
            current_cluster_length += sentence_tokens

        if current_cluster:
            clusters.append(" ".join(current_cluster))

        logger.info(f"分割されたチャンク数: {len(clusters)}")
        return clusters


================================================================================
File: src\modules\setup.py
================================================================================

# setup.py
from setuptools import setup, find_packages

setup(
    name="ir_news_release",
    version="0.1",
    packages=find_packages(),
    package_dir={"": "src"}
)

================================================================================
File: src\modules\slack\slack_notify.py
================================================================================

# slack_notifier.py
from pathlib import Path
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from utils.logging_config import get_logger
import os
import re
from typing import List, Dict, Optional
from dotenv import load_dotenv

logger = get_logger(__name__)

class MarkdownSlackFormatter:
    """
    Markdownテキストを Slack の Block Kit 形式にフォーマットするクラス。
    会社の決算情報を構造化された形式で表示し、インタラクティブな要素を提供します。
    """
    def format_content(self, markdown_content: str, ir_page_url: str) -> Dict:
        """
        Markdownコンテンツを Slack の Block Kit 形式に変換します。

        Args:
            markdown_content (str): 変換対象のMarkdownテキスト
            ir_page_url (str): IR情報ページへのURL

        Returns:
            Dict: Block Kit形式のメッセージ構造
        """
        # 会社名を抽出
        company_name = self._extract_company_name(markdown_content)
        
        # コンテンツをセクションに分割
        sections = self._split_sections(markdown_content)
        blocks = []

        # ヘッダーブロック（会社名）
        blocks.append(self._create_header_block(company_name))

        # 基本情報ブロック
        if sections['header']:
            blocks.append(self._create_section_block(
                self._format_summary(sections['header'])
            ))

        # セクション区切り
        blocks.append({"type": "divider"})

        # 各セクションのブロック
        for section in self._format_sections(sections['content']):
            blocks.append(self._create_section_block(
                f"*{section['title']}*\n{section['value']}"
            ))

        # フッター情報とボタン
        blocks.extend(self._create_footer_blocks(ir_page_url))

        return {"blocks": blocks}

    def _extract_company_name(self, markdown_content: str) -> str:
        """
        Markdownコンテンツから会社名を抽出します。
        前株式会社と後株式会社の両方のパターンに対応します。

        Args:
            markdown_content (str): 解析対象のMarkdownテキスト

        Returns:
            str: 抽出された会社名、見つからない場合は"不明な会社名"
        """
        try:
            # パターン1: 会社名欄での検索
            patterns = [
                r'会社名:\s*\*\*(株式会社[^*]+)\*\*',  # 前株式会社パターン
                r'会社名:\s*\*\*([^株]+株式会社)\*\*',  # 後株式会社パターン
                r'決算短信の要約\s*\(\*\*(株式会社[^*]+)\*\*\)',  # タイトルでの前株式会社
                r'決算短信の要約\s*\(\*\*([^株]+株式会社)\*\*\)'  # タイトルでの後株式会社
            ]
            
            for pattern in patterns:
                match = re.search(pattern, markdown_content)
                if match:
                    return match.group(1)
            
            return "不明な会社名"
            
        except Exception as e:
            logger.error(f"会社名の抽出中にエラーが発生しました: {str(e)}")
            return "不明な会社名"

    def _create_header_block(self, company_name: str) -> Dict:
        """ヘッダーブロックを作成します"""
        return {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"{company_name}の決算情報",
                "emoji": True
            }
        }

    def _create_section_block(self, text: str) -> Dict:
        """セクションブロックを作成します"""
        return {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": text
            }
        }

    def _create_footer_blocks(self, ir_page_url: str) -> List[Dict]:
        """フッター情報とボタンブロックを作成します"""
        return [
            {"type": "divider"},
            {
                "type": "context",
                "elements": [{
                    "type": "mrkdwn",
                    "text": "📊 金融庁 EDINET / GPT4oを使用して要約しています"
                }]
            },
            {
                "type": "actions",
                "elements": [{
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "📑 関連IR情報をもっと見る",
                        "emoji": True
                    },
                    "style": "primary",
                    "url": ir_page_url,
                    "action_id": "view_ir_info"
                }]
            }
        ]

    def _format_sections(self, content_sections: List[str]) -> List[Dict]:
        """セクションの内容をフォーマットします"""
        fields = []
        for section in content_sections:
            matches = re.match(r'(\d+\.\s*)(.*)', section)
            if matches:
                title = matches.group(2).strip()
                content = '\n'.join(section.split('\n')[1:])
                fields.append({
                    "title": f"{self._get_section_icon(title)} {title}",
                    "value": self._format_content_text(content),
                    "short": False
                })
        return fields

    def _format_content_text(self, content: str) -> str:
        """テキストコンテンツを整形します"""
        lines = []
        for line in content.split('\n'):
            line = line.strip()
            if line:
                if line.startswith('✦ '):
                    lines.append(line)
                elif line.startswith('- '):
                    lines.append(f"✦ {line[2:]}")
                else:
                    lines.append(line)
        return '\n'.join(lines)

    def _format_summary(self, header: str) -> str:
        """サマリー部分を整形します"""
        return '\n'.join(
            line.strip() for line in header.split('\n')[1:]
            if line.strip()
        )

    def _get_section_icon(self, title: str) -> str:
        """セクションに対応するアイコンを取得します"""
        icons = {
            'セグメント成長': '📊',
            '新しいトピック': '🆕',
            '損益計算書': '💹',
            '市場や競争環境': '🏢'
        }
        return icons.get(next((k for k in icons.keys() if k in title), ''), '📌')

    def _split_sections(self, content: str) -> Dict[str, any]:
        """コンテンツを各セクションに分割します"""
        parts = content.split('\n1.')
        header = parts[0].strip()
        content_sections = []

        if len(parts) > 1:
            remaining = '1.' + parts[1]
            current_section = []
            for line in remaining.split('\n'):
                if re.match(r'^\d+\.', line):
                    if current_section:
                        content_sections.append('\n'.join(current_section))
                    current_section = [line]
                else:
                    current_section.append(line)

            if current_section:
                content_sections.append('\n'.join(current_section))

        return {
            'header': header,
            'content': content_sections
        }

class SlackNotifier:
    """
    Slack通知を処理するクラス。
    環境設定の管理とメッセージの送信を担当します。
    """
    def __init__(self, env_path: str = "config/secrets.env"):
        # 環境変数の設定を読み込み
        self._load_environment(env_path)
        
        # Slackクライアントとフォーマッタを初期化
        self.client = WebClient(token=self.slack_token)
        self.formatter = MarkdownSlackFormatter()
        logger.info("Slack通知システムの初期化が完了しました")

    def _load_environment(self, env_path: str):
        """環境変数をロードします"""
        dotenv_path = Path(env_path)
        if not dotenv_path.exists():
            raise FileNotFoundError(f".env ファイルが見つかりません: {env_path}")
        
        load_dotenv(dotenv_path)
        
        self.slack_token = os.getenv("SLACK_BOT_TOKEN")
        if not self.slack_token:
            raise ValueError("SLACK_BOT_TOKEN が設定されていません")

        logger.info("環境設定のロードが完了しました")

    def send_formatted_markdown(self, channel: str, markdown_content: str, ir_page_url: str):
        """
        フォーマットされたMarkdownをSlackに送信します。
        ボットの表示名とアイコンをカスタマイズして送信を行います。

        Args:
            channel (str): 送信先のSlackチャンネルID
            markdown_content (str): 送信するMarkdown形式のコンテンツ
            ir_page_url (str): IR情報ページのURL
        """
        try:
            formatted_content = self.formatter.format_content(
                markdown_content, ir_page_url
            )
            
            # 基本のメッセージ内容にボットの表示設定を追加
            message_params = {
                **formatted_content,  # 既存のフォーマット済みコンテンツ
                "channel": channel,
                "username": "決算通知bot",  # ボットの表示名
                "icon_emoji": ":chart_with_upwards_trend:",  # 📈 グラフ上昇の絵文字
                # または画像URLを使用する場合：
                # "icon_url": "https://example.com/path/to/bot-icon.png"
            }
            
            response = self.client.chat_postMessage(**message_params)
            logger.info(f"Slack通知を送信しました: {response['ts']}")
                
        except SlackApiError as e:
            logger.error(f"Slack API エラー: {e.response['error']}")
            raise
        except Exception as e:
            logger.error(f"予期せぬエラーが発生しました: {e}")
            raise

================================================================================
File: src\modules\spreadsheet_to_edinet.py
================================================================================

# spreadsheet_to_edinet.py

from datetime import datetime
from utils.environment import EnvironmentUtils as env
from utils.spreadsheet import SpreadsheetService
from modules.edinet.operations import EDINETOperations
from modules.pdfSummary.process_drive_file import process_drive_file
from utils.drive_handler import DriveHandler
from utils.date_utils import parse_date_string
from modules.slack.slack_notify import SlackNotifier

from utils.logging_config import get_logger

# 名前付きロガーを取得
logger = get_logger(__name__)

def log_download_to_sheet(spreadsheet_service, spreadsheet_id, log_sheet_name, log_data):
    """
    ダウンロードしたデータをログシートに記録する。
    ヘッダーを動的に取得し、列を特定して操作する。
    """
    try:
        sheet_data = spreadsheet_service.get_sheet_data(spreadsheet_id, log_sheet_name)

        if not sheet_data:
            logger.info(f"Log sheet '{log_sheet_name}' is empty. Initializing headers.")
            # デフォルトのヘッダーを使用して初期化
            default_headers = [
                'Release_Date',
                'EDINET_code',
                'stock_code',
                'corp_name',
                'doc_type',
                'drive_raw_data_file_name',
                'drive_raw_data_file_url',
                'drive_summary_file_urls',  # 新しいカラムを追加
                'timestamp'
            ]
            spreadsheet_service.update_sheet_data(
                spreadsheet_id, log_sheet_name, [default_headers]
            )
            sheet_data = [default_headers]

        # ヘッダー行を取得
        headers = sheet_data[0]
        logger.info(f"Retrieved headers: {headers}")

        # データ行を追加
        logger.info(f"Appending log data to sheet '{log_sheet_name}'.")
        spreadsheet_service.append_sheet_data(
            spreadsheet_id, log_sheet_name, log_data
        )
        logger.info("Log data appended successfully.")
    except Exception as e:
        logger.error(f"Failed to append log data to sheet '{log_sheet_name}': {e}")
        raise

def process_spreadsheet_data(config):
    """
    スプレッドシートデータを基に EDINET API を呼び出し、結果を Google Drive に直接保存。
    結果を log シートに記録し、要約を Slack に通知。
    """
    try:
        # 環境変数と設定ファイルのロード
        env.load_env()

        # サービス初期化
        spreadsheet_service = SpreadsheetService()

        # スプレッドシートIDとログシート名を取得
        spreadsheet_id = spreadsheet_service.get_spreadsheet_id("SPREADSHEET", "ss_id_list")
        log_sheet_name = "log"

        # 日付範囲を取得
        try:
            start_date = parse_date_string(env.get_config_value("DATE_RANGE", "start_date"))
            end_date = parse_date_string(env.get_config_value("DATE_RANGE", "end_date"))
            logger.info(f"Using date range from settings: {start_date} to {end_date}")
        except ValueError as e:
            logger.error(f"Invalid date range configuration: {e}")
            raise

        # SlackNotifier の初期化
        slack_notifier = SlackNotifier(env_path="config/secrets.env")
        # Slack チャンネル名を設定ファイルから取得
        slack_channel = env.get_config_value("SLACK", "channel_id")

        # list シートのデータを取得
        list_data = spreadsheet_service.get_sheet_data(spreadsheet_id, "list")
        if not list_data:
            logger.error("No data found in the 'list' sheet.")
            return

        headers = list_data[0]
        data_rows = list_data[1:]
        if "EDINET_code" not in headers or "ir_page_url" not in headers or "check" not in headers:
            logger.error("'EDINET_code', 'ir_page_url', or 'check' column not found in the 'list' sheet.")
            return

        # 必要な列のインデックスを取得
        edinet_code_index = headers.index("EDINET_code")
        ir_page_url_index = headers.index("ir_page_url")
        check_index = headers.index("check")

        edinet_operations = EDINETOperations()

        # DriveHandler の初期化
        service_account_file = env.get_service_account_file()
        drive_handler = DriveHandler(str(service_account_file))

        for row_index, row in enumerate(data_rows, start=2):
            # `check`列がTRUEでない場合はスキップ
            check_value = row[check_index] if check_index < len(row) else "FALSE"
            if check_value.upper() != "TRUE":
                logger.info(f"Skipping row {row_index}: check value is not TRUE.")
                continue

            # 必要なデータを取得
            edinet_code = row[edinet_code_index]
            stock_code = row[headers.index("stock_code")] if "stock_code" in headers else ""
            corp_name = row[headers.index("corp_name")] if "corp_name" in headers else ""
            ir_page_url = row[ir_page_url_index] if ir_page_url_index < len(row) else ""

            logger.info(f"Processing row {row_index}: EDINET_code = {edinet_code}")

            if not ir_page_url:
                logger.warning(f"No IR page URL found for EDINET_code {edinet_code}.")
                continue

            try:
                documents = edinet_operations.get_documents_for_date_range(
                    start_date, end_date, [edinet_code]
                )

                for document in documents:
                    doc_id = document.get("docID")
                    doc_type_code = document.get("docTypeCode")
                    release_date = document.get("submitDateTime").split(" ")[0]
                    doc_type_name = EDINETOperations.TARGET_DOC_TYPES.get(doc_type_code, "不明")

                    # ファイル名生成
                    file_name = f"{edinet_code}_{doc_id}_{release_date.replace('-', '')}.pdf"

                    # フォルダの取得または作成
                    folder_id = drive_handler.get_or_create_folder(
                        folder_name=edinet_code,
                        parent_folder_id=env.get_config_value("DRIVE", "parent_folder_id")
                    )

                    # ドキュメントデータを取得
                    doc_data = edinet_operations.fetch_document_data(doc_id, doc_type_code)

                    if doc_data:
                        # Google Drive にアップロード
                        file_id = drive_handler.upload_file(
                            file_name=file_name,
                            file_content=doc_data,
                            folder_id=folder_id
                        )

                        # PDFを要約してGoogle Driveに保存
                        try:
                            summary_file_ids = process_drive_file(file_id, folder_id)
                            summary_urls = [
                                f"https://drive.google.com/file/d/{fid}/view" for fid in summary_file_ids
                            ]
                        except Exception as e:
                            logger.error(f"Failed to summarize PDF: {e}")
                            summary_file_ids = []
                            summary_urls = []

                        # ログデータの作成と記録
                        file_url = f"https://drive.google.com/file/d/{file_id}/view"
                        log_data = [
                            [
                                release_date,
                                edinet_code,
                                stock_code,
                                corp_name,
                                doc_type_name,
                                file_name,
                                file_url,
                                ", ".join(summary_urls),
                                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            ]
                        ]
                        log_download_to_sheet(
                            spreadsheet_service, spreadsheet_id, log_sheet_name, log_data
                        )
                        logger.info(f"File uploaded to Drive with URL: {file_url}")

                        # Slack通知の処理を追加
                        if summary_file_ids:
                            for summary_file_id in summary_file_ids:
                                try:
                                    markdown_content = drive_handler.get_file_content(summary_file_id)
                                    slack_notifier.send_formatted_markdown(
                                        slack_channel, markdown_content, ir_page_url
                                    )
                                    logger.info(f"Slackに要約を送信しました。ファイル ID: {summary_file_id}")
                                except Exception as e:
                                    logger.error(f"Slack通知中にエラーが発生しました（ファイル ID: {summary_file_id}）: {e}")
                        else:
                            logger.warning("要約ファイルがないため、Slack通知は行いませんでした。")

                    else:
                        logger.warning(f"Failed to fetch document data: ID={doc_id}")

            except Exception as e:
                logger.error(f"Error processing EDINET_code {edinet_code}: {e}")
    except Exception as e:
        logger.error(f"Failed to process spreadsheet data: {e}")
        raise

================================================================================
File: src\utils\__init__.py
================================================================================

 


================================================================================
File: src\utils\date_utils.py
================================================================================

from datetime import datetime, timedelta

def parse_date_string(date_str: str) -> datetime:
    """
    日付文字列を解析して datetime オブジェクトを返す。
    "yesterday" が指定された場合は前日の日付を返す。
    """
    if date_str.lower() == "yesterday":
        return datetime.now() - timedelta(days=1)
    return datetime.strptime(date_str, "%Y-%m-%d")


================================================================================
File: src\utils\drive_handler.py
================================================================================

# src/utils/drive_handler.py

import io
from googleapiclient.discovery import build
from google.oauth2 import service_account
from googleapiclient.http import MediaIoBaseDownload, MediaIoBaseUpload
from pathlib import Path
from datetime import datetime

from utils.logging_config import get_logger

logger = get_logger(__name__)

class DriveHandler:
    def __init__(self, service_account_file: str):
        """
        Google Drive API のハンドラーを初期化します。

        Args:
            service_account_file (str): サービスアカウントのキー JSON ファイルのパス。
        """
        self.service_account_file = service_account_file
        try:
            self.credentials = service_account.Credentials.from_service_account_file(
                self.service_account_file,
                scopes=["https://www.googleapis.com/auth/drive"]
            )
            self.service = build("drive", "v3", credentials=self.credentials)
            logger.info("Google Drive API サービスが正常に初期化されました。")
        except Exception as e:
            logger.error(f"Google Drive API の初期化中にエラーが発生しました: {e}")
            raise

    def get_file_content(self, file_id: str) -> str:
        """
        指定されたGoogle Driveファイルの内容を取得します。

        Args:
            file_id (str): Google DriveのファイルID

        Returns:
            str: ファイルの内容
        """
        try:
            request = self.service.files().get_media(fileId=file_id)
            file_content = request.execute()
            content = file_content.decode("utf-8")  # Markdown ファイルは通常 UTF-8 形式
            logger.info(f"ファイル内容を取得しました。ファイルID: {file_id}")
            return content
        except Exception as e:
            logger.error(f"ファイル内容の取得中にエラーが発生しました。ファイルID: {file_id}, エラー: {e}")
            raise

    def save_summary_to_drive(self, folder_id: str, summary: str, file_name: str) -> str:
        """
        要約を Google Drive に保存します。一意のファイル名を生成するため、タイムスタンプを付与します。

        Args:
            folder_id (str): 保存先フォルダのID
            summary (str): 保存する要約内容
            file_name (str): 保存するファイル名

        Returns:
            str: 保存されたファイルのID
        """
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            unique_file_name = f"{Path(file_name).stem}_{timestamp}{Path(file_name).suffix}"
            logger.info(f"要約を Google Drive に保存します。ファイル名: {unique_file_name}")

            file_metadata = {
                "name": unique_file_name,
                "parents": [folder_id]
            }

            media = MediaIoBaseUpload(
                io.BytesIO(summary.encode("utf-8")),
                mimetype="text/markdown"
            )

            file = self.service.files().create(
                body=file_metadata,
                media_body=media,
                fields="id"
            ).execute()

            file_id = file.get("id")
            logger.info(f"要約を Google Drive に保存しました。ファイル ID: {file_id}")
            return file_id
        except Exception as e:
            logger.error(f"要約ファイルの保存中にエラーが発生しました: {e}")
            raise

    def download_pdf_from_drive(self, file_id: str) -> str:
        """
        Google Drive からPDFファイルをダウンロードします。

        Args:
            file_id (str): ダウンロードするファイルのGoogle Drive ID

        Returns:
            str: ダウンロードしたファイルのローカルパス
        """
        try:
            # ファイルのメタデータを取得
            file_metadata = self.service.files().get(fileId=file_id).execute()
            file_name = file_metadata.get('name')

            # ダウンロード先のパスを設定
            download_dir = Path("downloads")
            download_dir.mkdir(exist_ok=True)
            local_path = download_dir / file_name

            # ファイルをダウンロード
            request = self.service.files().get_media(fileId=file_id)
            fh = io.BytesIO()
            downloader = MediaIoBaseDownload(fh, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
                if status:
                    logger.debug(f"Download {int(status.progress() * 100)}%.")

            # ダウンロードした内容をローカルファイルに保存
            with open(local_path, 'wb') as f:
                f.write(fh.getvalue())

            logger.info(f"ファイルをダウンロードしました: {local_path}")
            return str(local_path)
        except Exception as e:
            logger.error(f"ファイルのダウンロード中にエラーが発生しました: {e}")
            raise

    def get_or_create_folder(self, folder_name: str, parent_folder_id: str = None) -> str:
        """
        指定された名前のフォルダを取得または作成します。

        Args:
            folder_name (str): フォルダ名。
            parent_folder_id (str, optional): 親フォルダのID。

        Returns:
            str: フォルダのID。
        """
        try:
            # フォルダ検索クエリを構築
            query = f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
            if parent_folder_id:
                query += f" and '{parent_folder_id}' in parents"

            # フォルダを検索
            results = self.service.files().list(
                q=query,
                spaces="drive",
                fields="files(id, name)",
                pageSize=1
            ).execute()
            files = results.get("files", [])

            if files:
                folder_id = files[0]["id"]
                logger.info(f"既存のフォルダを使用します。フォルダ名: '{folder_name}', フォルダID: {folder_id}")
                return folder_id
            else:
                # フォルダが存在しない場合は作成
                file_metadata = {
                    "name": folder_name,
                    "mimeType": "application/vnd.google-apps.folder",
                    "parents": [parent_folder_id] if parent_folder_id else [],
                }
                folder = self.service.files().create(
                    body=file_metadata,
                    fields="id"
                ).execute()
                folder_id = folder.get("id")
                logger.info(f"新規フォルダを作成しました。フォルダ名: '{folder_name}', フォルダID: {folder_id}")
                return folder_id
        except Exception as e:
            logger.error(f"フォルダの取得または作成中にエラーが発生しました: {e}")
            raise

    def upload_file(self, file_name: str, file_content: bytes, folder_id: str, mime_type: str = "application/pdf") -> str:
        """
        ファイルをGoogle Driveにアップロードします。
        既存の同名ファイルがある場合はスキップする。

        Args:
            file_name (str): アップロードするファイル名。
            file_content (bytes): アップロードするファイルの内容。
            folder_id (str): アップロード先のフォルダID。
            mime_type (str): ファイルのMIMEタイプ（デフォルトはPDF）。

        Returns:
            str: アップロードされたファイルのID。または既存のファイルのID。
        """
        try:
            # フォルダ内で同名ファイルを検索
            query = f"name='{file_name}' and '{folder_id}' in parents and trashed=false"
            results = self.service.files().list(
                q=query,
                spaces="drive",
                fields="files(id, name)",
                pageSize=1
            ).execute()
            existing_files = results.get("files", [])

            if existing_files:
                # 同名ファイルが存在する場合はスキップ
                file_id = existing_files[0]["id"]
                logger.info(f"同名ファイルが既に存在するためスキップ: '{file_name}' (フォルダID: {folder_id}, ファイルID: {file_id})")
                return file_id

            # ファイルのメタデータを設定
            file_metadata = {
                "name": file_name,
                "parents": [folder_id],
            }

            # ファイルをアップロード
            media = MediaIoBaseUpload(
                io.BytesIO(file_content),
                mimetype=mime_type
            )
            uploaded_file = self.service.files().create(
                body=file_metadata,
                media_body=media,
                fields="id"
            ).execute()
            file_id = uploaded_file.get("id")
            logger.info(f"ファイルをアップロードしました: '{file_name}' (フォルダID: {folder_id}, ファイルID: {file_id})")
            return file_id
        except Exception as e:
            logger.error(f"ファイルのアップロードに失敗しました: {e}")
            raise


================================================================================
File: src\utils\environment.py
================================================================================

#enviroment.py
import os
from pathlib import Path
from dotenv import load_dotenv
from typing import Optional, Any
import configparser

class EnvironmentUtils:
    """プロジェクト全体で使用する環境関連のユーティリティクラス"""

    # プロジェクトルートのデフォルト値
    BASE_DIR = Path(__file__).resolve().parent.parent.parent

    @staticmethod
    def set_project_root(path: Path) -> None:
        """
        プロジェクトのルートディレクトリを設定します。

        Args:
            path (Path): 新しいプロジェクトルート
        """
        EnvironmentUtils.BASE_DIR = path

    @staticmethod
    def get_project_root() -> Path:
        """
        プロジェクトのルートディレクトリを取得します。

        Returns:
            Path: プロジェクトのルートディレクトリ
        """
        return EnvironmentUtils.BASE_DIR

    @staticmethod
    def load_env(env_file: Optional[Path] = None) -> None:
        """
        環境変数を .env ファイルからロードします。

        Args:
            env_file (Optional[Path]): .env ファイルのパス
        """
        env_file = env_file or (EnvironmentUtils.BASE_DIR / "config" / "secrets.env")

        if not env_file.exists():
            raise FileNotFoundError(f"{env_file} が見つかりません。正しいパスを指定してください。")

        load_dotenv(env_file)

    @staticmethod
    def get_env_var(key: str, default: Optional[Any] = None) -> Any:
        """
        環境変数を取得します。

        Args:
            key (str): 環境変数のキー
            default (Optional[Any]): デフォルト値

        Returns:
            Any: 環境変数の値またはデフォルト値
        """
        return os.getenv(key, default)

    @staticmethod
    def get_config_file(file_name: str = "settings.ini") -> Path:
        """
        設定ファイルのパスを取得します。

        Args:
            file_name (str): 設定ファイル名

        Returns:
            Path: 設定ファイルのパス

        Raises:
            FileNotFoundError: 指定された設定ファイルが見つからない場合
        """
        config_path = EnvironmentUtils.BASE_DIR / "config" / file_name
        if not config_path.exists():
            raise FileNotFoundError(f"Configuration file not found: {config_path}")
        return config_path

    @staticmethod
    def get_config_value(section: str, key: str, default: Optional[Any] = None) -> Any:
        """
        設定ファイルから指定のセクションとキーの値を取得します。

        Args:
            section (str): セクション名
            key (str): キー名
            default (Optional[Any]): デフォルト値

        Returns:
            Any: 設定値
        """
        config_path = EnvironmentUtils.get_config_file()
        config = configparser.ConfigParser()
        config.read(config_path, encoding='utf-8')  # エンコーディングを明示的に指定

        if not config.has_section(section):
            return default
        if not config.has_option(section, key):
            return default

        value = config.get(section, key, fallback=default)

        # 型変換
        if value.isdigit():
            return int(value)
        if value.replace('.', '', 1).isdigit():
            return float(value)
        if value.lower() in ['true', 'false']:
            return value.lower() == 'true'
        return value

    @staticmethod
    def resolve_path(path: str) -> Path:
        """
        指定されたパスをプロジェクトルートに基づいて絶対パスに変換します。

        Args:
            path (str): 相対パスまたは絶対パス

        Returns:
            Path: 解決された絶対パス
        """
        resolved_path = Path(path)
        if not resolved_path.is_absolute():
            resolved_path = EnvironmentUtils.get_project_root() / resolved_path

        if not resolved_path.exists():
            raise FileNotFoundError(f"Resolved path does not exist: {resolved_path}")

        return resolved_path

    @staticmethod
    def get_service_account_file() -> Path:
        """
        サービスアカウントファイルのパスを取得します。

        Returns:
            Path: サービスアカウントファイルの絶対パス

        Raises:
            FileNotFoundError: ファイルが存在しない場合
        """
        # 環境変数または設定ファイルから取得
        service_account_file = EnvironmentUtils.get_env_var(
            "SERVICE_ACCOUNT_FILE",
            default=EnvironmentUtils.get_config_value("GOOGLE", "service_account_file", default="config/service_account.json")
        )

        # パスを解決
        return EnvironmentUtils.resolve_path(service_account_file)

    @staticmethod
    def get_environment() -> str:
        """
        環境変数 APP_ENV を取得します。
        デフォルト値は 'development' です。

        Returns:
            str: 現在の環境（例: 'development', 'production'）
        """
        return EnvironmentUtils.get_env_var("APP_ENV", "development")

    @staticmethod
    def get_openai_api_key():
        """
        Get the OpenAI API key from the environment variables.
        """
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise ValueError("OPENAI_API_KEY が設定されていません。環境変数を確認してください。")
        return api_key

    @staticmethod
    def get_openai_model():
        """
        Get the OpenAI model name from the environment variables.
        Defaults to 'gpt-4o' if not explicitly set.
        """
        return os.getenv("OPENAI_MODEL", "gpt-4o")

================================================================================
File: src\utils\logging_config.py
================================================================================

import logging
import logging.handlers
from datetime import datetime
from pathlib import Path
from icecream import ic
from typing import Optional

class LoggingConfig:
    _initialized = False

    def __init__(self, use_icecream: bool = False):
        """
        ログ設定を初期化します。

        Args:
            use_icecream (bool): IceCreamデバッグを有効化するか
        """
        if LoggingConfig._initialized:
            return  # 再初期化を防止

        self.log_dir = Path("logs")
        self.log_level = logging.INFO
        self.log_format = "%(asctime)s - %(name)s - [%(levelname)s] - %(message)s"
        self.use_icecream = use_icecream

        self.setup_logging()
        self.initialize_icecream()

        LoggingConfig._initialized = True  # 初期化済みフラグを設定

    def setup_logging(self) -> None:
        """
        ロギング設定をセットアップします。
        """
        if not self.log_dir.exists():
            self.log_dir.mkdir(parents=True, exist_ok=True)

        log_file = self.log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"

        handlers = [
            logging.handlers.TimedRotatingFileHandler(
                log_file, when="midnight", interval=1, backupCount=30, encoding="utf-8"
            ),
            logging.StreamHandler(),
        ]

        logging.basicConfig(
            level=self.log_level,
            format=self.log_format,
            handlers=handlers,
        )

        logging.getLogger().info("Logging setup complete.")

    def initialize_icecream(self) -> None:
        """
        IceCreamのデバッグ設定を初期化します。
        """
        if self.use_icecream:
            ic.configureOutput(includeContext=True)
            logging.getLogger().info("IceCream debugging enabled.")
        else:
            ic.disable()
            logging.getLogger().info("IceCream debugging disabled.")

def get_logger(name: Optional[str] = None, use_icecream: bool = False) -> logging.Logger:
    """
    名前付きロガーを取得します。

    Args:
        name (Optional[str]): ロガー名
        use_icecream (bool): IceCreamデバッグを有効化するか

    Returns:
        logging.Logger: 名前付きロガー
    """
    LoggingConfig(use_icecream=use_icecream)
    return logging.getLogger(name)


================================================================================
File: src\utils\spreadsheet.py
================================================================================

import os
from pathlib import Path
from configparser import ConfigParser
from google.oauth2.service_account import Credentials
from googleapiclient.discovery import build

from utils.environment import EnvironmentUtils as env
from utils.logging_config import get_logger

class SpreadsheetService:
    """スプレッドシート操作を管理するクラス"""

    def __init__(self):
        """
        初期化メソッド。
        ログ設定とGoogle Sheets APIサービスの初期化を行います。
        """
        self.logger = get_logger(__name__)
        self.logger.info("Initializing SpreadsheetService...")

        # サービスアカウントファイルを取得
        try:
            # 環境変数または設定ファイルから取得
            service_account_file = os.getenv("SERVICE_ACCOUNT_FILE", "config/service_account.json")
            
            # パスを解決
            service_account_path = self._resolve_path(service_account_file)

            # Google 認証情報をロード
            if not service_account_path.exists():
                raise FileNotFoundError(f"Service account file not found: {service_account_path}")

            self.credentials = Credentials.from_service_account_file(str(service_account_path))
            self.logger.info("Service account file successfully loaded.")
        except Exception as e:
            self.logger.error(f"Failed to load service account file: {e}")
            raise

        # Google Sheets API サービスを初期化
        try:
            self.service = build("sheets", "v4", credentials=self.credentials)
            self.logger.info("Google Sheets API service initialized successfully.")
        except Exception as e:
            self.logger.error(f"Failed to initialize Google Sheets API service: {e}")
            raise

        # ConfigParser で設定ファイルをロード
        try:
            config_path = env.get_config_file()
            self.logger.info(f"Loading configuration from: {config_path}")
            self.config = ConfigParser()

            if not config_path.exists():
                raise FileNotFoundError(f"Configuration file not found: {config_path}")

            self.config.read(config_path, encoding='utf-8')  # エンコーディングを明示的に指定
        except Exception as e:
            self.logger.error(f"Error loading configuration: {e}")
            raise

    def _resolve_path(self, path: str) -> Path:
        """
        与えられたパスを絶対パスに解決します。

        :param path: 解決するパス
        :return: 絶対パス
        """
        resolved_path = Path(path)
        if not resolved_path.is_absolute():
            resolved_path = env.get_project_root() / resolved_path

        self.logger.debug(f"Resolved path: {resolved_path}")
        return resolved_path

    def get_sheet_data(self, spreadsheet_id: str, sheet_name: str):
        """
        指定されたスプレッドシートのデータを取得します。

        Args:
            spreadsheet_id (str): スプレッドシートID
            sheet_name (str): シート名

        Returns:
            List[List[str]]: スプレッドシートのデータ
        """
        self.logger.info(f"Fetching data from Spreadsheet ID: {spreadsheet_id}, Sheet Name: {sheet_name}")
        try:
            sheet = self.service.spreadsheets()
            result = sheet.values().get(spreadsheetId=spreadsheet_id, range=sheet_name).execute()
            data = result.get("values", [])
            self.logger.debug(f"Data fetched: {data}")
            return data
        except Exception as e:
            self.logger.error(f"Error fetching data for Sheet '{sheet_name}': {e}")
            raise

    def get_spreadsheet_id(self, section: str, option: str) -> str:
        """
        スプレッドシートIDを取得します。

        Args:
            section (str): 設定ファイルのセクション名
            option (str): 設定項目名

        Returns:
            str: スプレッドシートID
        """
        self.logger.info(f"Fetching Spreadsheet ID from section: {section}, option: {option}")
        try:
            if not self.config.has_section(section):
                raise ValueError(f"Section '{section}' not found in the configuration.")
            if not self.config.has_option(section, option):
                raise ValueError(f"Option '{option}' not found in section '{section}'.")
            spreadsheet_id = self.config.get(section, option)
            self.logger.debug(f"Spreadsheet ID retrieved: {spreadsheet_id}")
            return spreadsheet_id
        except Exception as e:
            self.logger.error(f"Error retrieving Spreadsheet ID: {e}")
            raise

    def append_sheet_data(self, spreadsheet_id: str, sheet_name: str, rows: list):
        """
        指定されたスプレッドシートのシートに行データを追加します。

        Args:
            spreadsheet_id (str): スプレッドシートID
            sheet_name (str): シート名
            rows (list): 追加する行データのリスト

        Returns:
            dict: APIのレスポンス
        """
        self.logger.info(f"Appending data to Spreadsheet ID: {spreadsheet_id}, Sheet Name: {sheet_name}")
        try:
            range_ = f"{sheet_name}!A1"
            body = {"values": rows}

            response = self.service.spreadsheets().values().append(
                spreadsheetId=spreadsheet_id,
                range=range_,
                valueInputOption="RAW",
                insertDataOption="INSERT_ROWS",
                body=body
            ).execute()

            self.logger.debug(f"Data appended successfully to Sheet: {sheet_name}, Response: {response}")
            return response
        except Exception as e:
            self.logger.error(f"Error appending data to sheet '{sheet_name}': {e}")
            raise


================================================================================
File: tests\__init__.py
================================================================================

 


================================================================================
File: tests\test_drive_file.py
================================================================================

#test_drive_file.py
import sys
from pathlib import Path

# プロジェクトのルートディレクトリを計算してPythonパスに追加
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "src"))  # srcディレクトリも追加

# modules配下のpdf_mainからインポート
from modules.pdfSummary.pdf_main import test_process_drive_file

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Test processing a Google Drive PDF file by its file ID.")
    parser.add_argument("file_id", help="The Google Drive file ID of the PDF to process.")
    parser.add_argument("drive_folder_id", help="The Google Drive folder ID to save the summary.")
    args = parser.parse_args()

    try:
        test_process_drive_file(args.file_id, args.drive_folder_id)
    except Exception as e:
        print(f"エラーが発生しました: {e}")

================================================================================
File: tests\test_log.py
================================================================================

import logging
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path
from datetime import datetime

def test_logging():
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    log_file = log_dir / f"app_{datetime.now().strftime('%Y%m%d')}.log"

    logger = logging.getLogger("test_logger")
    logger.setLevel(logging.DEBUG)

    handler = TimedRotatingFileHandler(
        log_file,
        when='midnight',
        interval=1,
        backupCount=30,
        encoding='utf-8'
    )

    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    logger.info("This is a test log message.")

if __name__ == "__main__":
    test_logging()


================================================================================
File: tests\test_slack_notify.py
================================================================================

import sys
from pathlib import Path

# プロジェクトのルートディレクトリを計算して Python パスに追加
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "src"))  # src ディレクトリも追加

from modules.slack.slack_notify import test_slack_notification_with_file

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Test sending a Slack notification with a file link.")
    parser.add_argument("slack_channel", help="The Slack channel to send the notification.")
    parser.add_argument("message", help="The message to send to the Slack channel.")
    parser.add_argument("file_id", help="The Google Drive file ID to share.")
    parser.add_argument("--env_path", default="config/secrets.env", help="Path to the .env file (default: config/secrets.env).")
    args = parser.parse_args()

    try:
        test_slack_notification_with_file(args.slack_channel, args.message, args.file_id, args.env_path)
    except Exception as e:
        print(f"エラーが発生しました: {e}")


================================================================================
File: tests\test_slack_notify_with_file.py
================================================================================

import sys
from pathlib import Path

# プロジェクトのルートディレクトリを計算して Python パスに追加
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "src"))  # src ディレクトリも追加

from modules.slack.slack_notify import SlackNotifier

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Slack通知をテストするスクリプト。")
    parser.add_argument("slack_channel", help="Slackの通知先チャンネル名またはID。")
    parser.add_argument("file_id", help="Google Drive上のファイルID。")
    args = parser.parse_args()

    try:
        notifier = SlackNotifier(env_path="config/secrets.env")
        notifier.notify_with_file_content(args.slack_channel, args.file_id)
    except Exception as e:
        print(f"エラーが発生しました: {e}")


================================================================================
File: tests\test_slack_notify_with_markdown.py
================================================================================

#test_slack_notify_with_markdown.py
import sys
from pathlib import Path

# プロジェクトのルートディレクトリを計算して Python パスに追加
project_root = Path(__file__).resolve().parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "src"))  # src ディレクトリも追加

from modules.slack.slack_notify import SlackNotifier
from modules.slack.drive_handler import DriveHandler
from utils.logging_config import get_logger


logger = get_logger(__name__)

def test_slack_notification_with_markdown(slack_channel: str, file_id: str, env_path: str = "config/secrets.env"):
    try:
        notifier = SlackNotifier(env_path=env_path)
        drive_handler = DriveHandler(notifier.service_account_file)
        content = drive_handler.get_file_content(file_id)
        notifier.send_formatted_markdown(slack_channel, content)
    except Exception as e:
        logger.error(f"Slack通知中にエラーが発生しました: {e}")
        raise

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python test_slack_notify_with_markdown.py [channel] [file_id]")
        sys.exit(1)
    
    test_slack_notification_with_markdown(sys.argv[1], sys.argv[2])

================================================================================
File: tests\test_spreadsheet.py
================================================================================

import sys
from pathlib import Path

# プロジェクトのルートディレクトリをパスに追加
project_root = Path(__file__).resolve().parent.parent  # ir_news_release ディレクトリ
sys.path.append(str(project_root / "src"))

from utils.spreadsheet import SpreadsheetService
from icecream import ic

# 設定ファイルのパス
CONFIG_PATH = Path("config/settings.ini")

def test_list_sheet_headers():
    """list シートのヘッダ行を取得して確認"""
    service = SpreadsheetService(CONFIG_PATH)
    data = service.get_sheet_data("list")

    if data:
        ic(data[0])  # 最初の行を出力（ヘッダ行）
    else:
        print("No data found in 'list' sheet.")

if __name__ == "__main__":
    test_list_sheet_headers()


================================================================================
File: tests\test_template.py
================================================================================

import sys
from pathlib import Path
import os
from icecream import ic
from configparser import ConfigParser

# プロジェクトのルートディレクトリを計算し、`src` を `sys.path` に追加
project_root = Path(__file__).resolve().parent.parent  # ir_news_release ディレクトリ
src_path = project_root / "src"  # src ディレクトリ
sys.path.insert(0, str(src_path))  # sys.path の先頭に追加

from utils.logging_config import get_logger

# 設定ファイルのパス
CONFIG_PATH = project_root / "config/settings.ini"
ENV_PATH = project_root / "config/secrets.env"

def load_environment_variables(env_path):
    """
    secrets.env ファイルから環境変数を読み込む
    """
    if not env_path.exists():
        raise FileNotFoundError(f"Environment file not found: {env_path}")
    
    with open(env_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):  # 空行やコメントをスキップ
                continue
            key, value = line.split("=", 1)
            os.environ[key] = value
    ic(f"Environment variables loaded from {env_path}")

def sample_function():
    """
    サンプル関数：Hello TOMONOKAI を出力し、ログとデバッグ出力を行う
    """
    # ロガー初期化
    logger = get_logger()
    logger.info("Starting sample function")

    # 設定ファイルの読み込み
    config = ConfigParser()
    if CONFIG_PATH.exists():
        config.read(CONFIG_PATH)
        ic(f"Configuration loaded: {CONFIG_PATH}")
    else:
        logger.error(f"Configuration file not found: {CONFIG_PATH}")

    # secrets.env の読み込み
    try:
        load_environment_variables(ENV_PATH)
        logger.info(f"Environment variables loaded successfully from {ENV_PATH}")
    except FileNotFoundError as e:
        logger.error(str(e))
        return

    # サンプル出力
    api_key = os.getenv("EDINET_API_KEY", "未設定")
    logger.info(f"EDINET_API_KEY: {api_key}")
    ic(f"EDINET_API_KEY: {api_key}")

    print("Hello TOMONOKAI")
    logger.info("Sample function completed successfully.")

if __name__ == "__main__":
    sample_function()

